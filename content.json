[{"title":"Git常用命令","date":"2018-10-19T09:28:38.000Z","path":"2018/10/19/Git/Git常用命令/","text":"git init 在本地当前目录初始化一个git仓库 git clone git status git log git add git diff git commit git reset git revert git rm git clean git mv git stash git branch git checkout git merge git tag git remote git fetch git pull git rebase git push","tags":[]},{"title":"设计模式","date":"2018-10-19T08:08:41.000Z","path":"2018/10/19/DesignPattern/设计模式/","text":"设计模式的分类设计模式分为三大类： 创建型模式，共五种： 工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式 结构型模式，共七种： 适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式 行为型模式，共十一种： 策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式 设计模式的六大原则1、单一职责原则 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 4、接口隔离原则（Interface Segregation Principle） 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5、迪米特法则（最少知道原则）（Demeter Principle） 一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 6、合成复用原则（Composite Reuse Principle） 原则是尽量首先使用合成/聚合的方式，而不是使用继承。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"幽静的小路","date":"2018-10-17T10:05:34.000Z","path":"2018/10/17/Journey/幽静的小路/","text":"蝴蝶效应的影响，在前期的时候，因为别人或者环境的影响，很长的一段时间，心情很悲伤，心态上的悲观，导致后来的我遇到自己所爱的事物时，心中想着我本可以，却发现怎么都追赶不上了，前期的一次心态不好，会对后来的自己产生巨大的影响。回想起来，当自己再经历一遍时，发现我还是不能改变环境和别人对我的影响，那时候的我是在感情用事吗？还是自己没有气度呢？唯一能做的是改变自己，改变自己的心态和状态。 人可以不认识人，但是灵魂认识灵魂如果你抓住深渊不放，深渊也会抓住你不放马太效应 凡是有的，还要加给他，叫他多余。没有的，连他所有的，也要夺过来。任何时候，不要太悲伤，其实自己拥有很多，so far so good。 一个人有多好就有多坏，常怀慈悲之心，生而为人，务必善良。","tags":[{"name":"悟","slug":"悟","permalink":"http://yoursite.com/tags/悟/"}]},{"title":"【Java并发】Java多线程Future的使用","date":"2018-10-17T09:07:10.000Z","path":"2018/10/17/Java并发/【Java并发】Java多线程Future的使用/","text":"Future模式简述 在传统单线程环境下，调用函数是同步的，必须等待程序返回结果后，才可进行其他处理。 Future模式下，调用方式改为异步。 Future模式的核心在于：充分利用主函数中的等待时间，利用等待时间处理其他任务，充分利用计算资源示例代码： 123456789101112131415161718import java.util.concurrent.Callable;public class ManipulationDataTask implements Callable&lt;String&gt; &#123; private String data; public ManipulationDataTask(String data) &#123; this.data = data; &#125; @Override public String call() throws Exception &#123; String data1 = data.toUpperCase(); System.out.println(Thread.currentThread().getName() + \"业务处理线程处理中...\"); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \"业务处理线程处理完成,处理好的数据为\" + data1); return data1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;public class MainTest &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; FutureTask&lt;String&gt; future1 = new FutureTask&lt;String&gt;(new ManipulationDataTask(\"abc\")); FutureTask&lt;String&gt; future2 = new FutureTask&lt;String&gt;(new ManipulationDataTask(\"def\")); FutureTask&lt;String&gt; future3 = new FutureTask&lt;String&gt;(new ManipulationDataTask(\"ghi\")); ManipulationDataTask manipulationDataTask = new ManipulationDataTask(\"jkl\"); ExecutorService executor = Executors.newFixedThreadPool(3); executor.submit(future1); executor.submit(future2); executor.submit(future3); Future&lt;String&gt; future4 =executor.submit(manipulationDataTask); System.out.println(\"请求完毕！\"); try &#123; System.out.println(\"主线程先去做点别的事\"); Thread.sleep(5000); System.out.println(\"主线程的事情做完了\"); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(\"主线程开始获取子任务处理完的结果\"); System.out.println(\"数据处理完成：\" + future1.get()); System.out.println(\"数据处理完成：\" + future2.get()); System.out.println(\"数据处理完成：\" + future3.get()); System.out.println(\"数据处理完成：\" + future4.get()); executor.shutdown(); &#125;&#125; 程序运行结果：12345678910111213141516请求完毕！主线程先去做点别的事pool-1-thread-1业务处理线程处理中...pool-1-thread-2业务处理线程处理中...pool-1-thread-3业务处理线程处理中...pool-1-thread-1业务处理线程处理完成,处理好的数据为ABCpool-1-thread-1业务处理线程处理中...pool-1-thread-2业务处理线程处理完成,处理好的数据为DEFpool-1-thread-3业务处理线程处理完成,处理好的数据为GHIpool-1-thread-1业务处理线程处理完成,处理好的数据为JKL主线程的事情做完了主线程开始获取子任务处理完的结果数据处理完成：ABC数据处理完成：DEF数据处理完成：GHI数据处理完成：JKL","tags":[{"name":"java并发","slug":"java并发","permalink":"http://yoursite.com/tags/java并发/"}]},{"title":"java关键字transient,volatile","date":"2018-10-15T10:30:53.000Z","path":"2018/10/15/Java/java关键字transient-volatile/","text":"被transient关键字修饰的变量不会被序列化被volatile关键字修饰的变量，每次被线程访问时，都会强制从共享内存中重读改变量的值，但是不具备原子性被volatile关键字修饰的变量的，具有以下两点特性： 保证了不同线程对该变量操作的内存可见性，不保证原子性。 禁止指令重排序 在java的内存模型中，JMM规定对于多个线程共享变量都存在主存中的，每个线程包含自己的工作内存，工作内存保存了主内存共享的变量，其中一个线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步会主内存中。在其他线程未将共享变量同步会自己的工作内存之前，共享变量的改变对其不可见的。也就是说其他线程的工作内存中的变量已经过时了。 volatile是通过内存屏障和禁止指令重排序来保证内存可见性的，一个线程对volatile变量的修改，能即刻被其他线程所见，但是不保证原子性。 使用volatile提供理想的线程安全，需要满足以下两个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 volatile变量不能用来做线程安全的计数器 volatile的适用场景 1. 状态标志注意：这种状态标记通常只有一种状态转换如果需要状态的来回转换，可以使用原子变量。 2. 一次性安全发布3. 独立观察定期“发布”观察结果供程序内部使用 4. “volatile bean”模式5. 开销较低“读-写锁”策略 状态位 一个线程写，多个线程读的场景","tags":[]},{"title":"Hello World","date":"2018-10-15T08:05:35.909Z","path":"2018/10/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"SpringAOP原理","date":"2018-10-01T15:06:32.000Z","path":"2018/10/01/Java/SpringAOP原理/","text":"AOP（Aspect-OrientedProgramming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。AOP使用场景 权限 缓存 内容传递 错误处理 懒加载 调试 记录跟踪 优化 校准 持久化 资源池 同步 事务","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"Github 提交代码 Emoji","date":"2017-08-09T15:55:41.000Z","path":"2017/08/09/Git/GithubEmoji/","text":"An emoji guide for your commit messages: gitmoji Code Emoji 描述 :art: :art: 改进代码的结构/格式 :zap: :zap: 提高性能 :fire: :fire: 删除代码或文件 :bug: :bug: 修复bug :ambulance: :ambulance: 关键修补程序 :sparkles: :sparkles: 引入新功能 :memo: :memo: 写文档 :rocket: :rocket: 部署项目 :lipstick: :lipstick: 更新UI和样式文件 :tada: :tada: 初始提交 :white_check_mark: :white_check_mark: 添加测试 :lock: :lock: 解决安全问题 :apple: :apple: 修改 macOS 下的一些问题 :penguin: :penguin: 修改 Linux 下的一些问题 :checkered_flag: :checkered_flag: 修改 Windows 下的一些问题 :robot: :robot: 修改 Android 下的一些问题 :green_apple: :green_apple: 修改 IOS 下的一些问题 :bookmark: :bookmark: 发布版本标签 :rotating_light: :rotating_light: 移除 linter 警告 :construction: :construction: 工作正在进行中 :green_heart: :green_heart: 修复CI构建 :arrow_down: :arrow_down: 降级依赖 :arrow_up: :arrow_up: 更新依赖 :construction_worker: :construction_worker: 添加CI构建系统 :chart_with_upwards_trend: :chart_with_upwards_trend: 添加分析或跟踪代码 :hammer: :hammer: 重构代码 :heavy_minus_sign: :heavy_minus_sign: 删除依赖关系 :whale: :whale: 关于Docker的工作 :heavy_plus_sign: :heavy_plus_sign: 添加依赖关系 :wrench: :wrench: 更改配置文件 :globe_with_meridians: :globe_with_meridians: 国际化和本地化 :pencil2: :pencil2: 修正打字错误 :hankey: :hankey: 编写不好的代码，需要改进 :rewind: :rewind: 还原更改 :twisted_rightwards_arrows: :twisted_rightwards_arrows: 合并分支 :package: :package: 更新已编译的文件或包 :alien: :alien: 由于外部API更改而更新代码 :truck: :truck: 移动或重命名文件 :page_facing_up: :page_facing_up: 添加或更新许可证 :boom: :boom: 引入爆炸改变 :bento: :bento: 添加或更新资源 :ok_hand: :ok_hand: 由于代码审查更改而更新代码 :wheelchair: :wheelchair: 改善无障碍 :bulb: :bulb: 文档化源代码 :beers: :beers: 沉迷写代码 :speech_balloon: :speech_balloon: 更新文本和常量 :card_file_box: :card_file_box: 执行数据库相关更改","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}]