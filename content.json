[{"title":"Java 线程池关闭","date":"2019-02-19T12:10:03.000Z","path":"2019/02/19/Java/Java-线程池关闭/","text":"12345678910111213public void close() &#123; if (scheduledExecutorService != null) &#123; scheduledExecutorService.shutdown(); try &#123; if (!scheduledExecutorService.awaitTermination(10, TimeUnit.SECONDS)) &#123; scheduledExecutorService.shutdownNow(); &#125; &#125; catch (InterruptedException e) &#123; scheduledExecutorService.shutdownNow(); &#125; scheduledExecutorService = null; &#125;&#125;","tags":[]},{"title":"【Java并发】java线程池","date":"2019-02-19T09:20:56.000Z","path":"2019/02/19/Java并发/【Java并发】java线程池/","text":"1. Executor Executor是线程池的顶级接口，只有一个方法execute() ExecutorService是Executor的子接口，提供了线程池生命周期管理的方法，一个可跟踪一个或多个异步任务执行情况返回Future的方法。 方法 功能描述 execute() 执行任务 shutdown() 调用后不再接收新任务，如果里面有任务，就执行完 shutdownNow() 调用后不再接收新任务，取消等待中的任务，返回等待执行的任务的list；有正在执行的任务，会尝试停止 isShutdown() 判断线程池是否完全停止 isTerminated() 判断线程池有任务在执行 submit() 提交带返回值的任务，返回值封装到Future中，通过Future.get()可以获取返回值 invokeAll() 执行一组任务 2. ThreadPoolExecutor2.1 构造方法123456789public ThreadPoolExecutor( int corePoolSize, //核心线程数 int maximumPoolSize, //最大线程数 long keepAliveTime, //保持存活时间 TimeUnit unit, //时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列 ThreadFactory threadFactory, //线程工厂 RejectedExecutionHandler handler //异常捕获器) 2.2 TimeUnit unit参数keepAliveTime的时间单位，有7种取值 TimeUnit.DAYS //天 TimeUnit.HOURS //小时 TimeUnit.MINUTES //分钟 TimeUnit.SECONDS //秒 TimeUnit.MILLISECONDS //毫秒 TimeUnit.MICROSECONDS //微妙 TimeUnit.NANOSECONDS //纳秒2.3 keepAliveTime当线程空闲时，所允许保存的最大时间，超过这个时间，线程将被释放销毁，但只针对于非核心线程。3. 阻塞队列3.1 BlockingQueue| 阻塞队列 | 功能描述 || —– | —– ||BlockingQueue | 阻塞队列的顶级接口，主要用于实现生产者消费者队列 ||BlockingDeque | 双端队列 ||SynchronousQueue | 同步队列，无界队列，直接提交策略，交替队列，在某次添加元素后必须等待其他线程取走后才能继续添加 ||LinkedBlockingQueue | 无界队列，基于链表的阻塞队列，可以并发运行，FIFO ||ArrayBlockingQueue | 基于数组的有界(固定大小的数组)阻塞队列，只有put方法和take方法才具有阻塞功能，公平性 fairness ||PriorityBlockingQueue | 基于优先级的阻塞队列，依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序 ||DelayQueue | 延时队列|4. 线程池工具类Executors|方法 | 功能描述 || —– | —– ||newCachedThreadPool() |创建一个可缓存的线程池||newFixedThreadPool() |创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待||newScheduledThreadPool()| 创建一个定长线程池，支持定时及周期性任务执行。||newSingleThreadExecutor()| 创建单线程化线程池，始终保证线程池中会有一个线程在。当某线程死去，会找继任者||defaultThreadFactory() |创建一个默认线程池工厂|","tags":[]},{"title":"Java创建Listener","date":"2019-02-18T11:05:47.000Z","path":"2019/02/18/Java/Java创建Listener/","text":"123456789101112131415161718192021222324252627282930313233import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class Listener implements Runnable&#123; private ScheduledExecutorService scheduledExecutorService; private static final int DEFAULT_INTERVAL = 100000; public Listener() &#123; int interval = DEFAULT_INTERVAL; this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(); scheduledExecutorService.scheduleWithFixedDelay(this, 0, interval, TimeUnit.MILLISECONDS); &#125; @Override public void run() &#123; Thread.currentThread().setName(&quot;XXXListener&quot;); System.out.println(&quot;exec check data.&quot;); &#125; public void close() &#123; if (scheduledExecutorService != null) &#123; scheduledExecutorService.shutdown(); try &#123; if (!scheduledExecutorService.awaitTermination(10, TimeUnit.SECONDS)) &#123; scheduledExecutorService.shutdownNow(); &#125; &#125; catch (InterruptedException e) &#123; scheduledExecutorService.shutdownNow(); &#125; scheduledExecutorService = null; &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Git使用中遇到的问题","date":"2019-02-18T10:47:36.000Z","path":"2019/02/18/Git/Git使用中遇到的问题/","text":"Git 放弃本地更改，拉取远端最新代码123git fetch --allgit reset --hard origin/mastergit pull Git commit信息写错了，更改commit信息12git commit --amend//执行此命令后，进入Vi编辑模式，第一句为Commit信息，更改保存退出即可","tags":[]},{"title":"Spring IOC","date":"2019-01-10T09:42:15.000Z","path":"2019/01/10/Spring-IOC/","text":"","tags":[]},{"title":"Git强制覆盖本地代码","date":"2018-12-10T03:41:08.000Z","path":"2018/12/10/Git/Git强制覆盖本地代码/","text":"git 强制覆盖git fetch --all git reset --hard origin/master git pull 单条执行 git fetch –all &amp;&amp; git reset –hard origin/master &amp;&amp; git pull","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"React总结","date":"2018-11-08T03:44:59.000Z","path":"2018/11/08/React学习/React总结/","text":"React特点： 虚拟dom 简单的UI开发逻辑 组件化 一个组件应该具有的特征： 可组合 可重用 可维护Jsx语法：在html中直接写Js代码，不加任何引号，允许html和js混写 组件的生命周期： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 和组件生命周期相关的几个方法： 123456789getDefaultProps //创建组建getInitialState //实例化状态componentWillMount //挂载前componentDidMount //挂载后componentWillReceiveProps //属性被改变时shouldComponentUpdate //是否更新componentWillUpdate //更新前componentDidUpdate //更新后componentWillUnmount //销毁前 1、ReactJs是基于组件化的开发，所以最终的页面应该是由若干个小组件组成的大组件。 2、可以通过属性，将值传递到组件内部，同理也可以通过属性将内部的结果传递到父级组件(留给大家研究)；要对某些值的变化做DOM操作的，要把这些值放到state中。 3、为组件添加外部css样式时，类名应该写成className而不是class;for是htmlFor，添加内部样式时，应该是style=&#123;&#123;opacity: this.state.opacity&#125;&#125;而不是style=&quot;opacity:{this.state.opacity};&quot;。 4、组件名称首字母必须大写。 5、变量名用{}包裹，且不能加双引号。ReactJS优缺点： 优点： React速度很快 浏览器兼容 兼容到IE8 模块化（1、 模块化组件 2、 对于每个组件方便独立进行开发和测试，提高了代码可维护性） 单向数据流 缺点： React只是MVC中V，并不是一个完整的框架React创建组件： 1.创建组件两种方式： 无状态组件 类组件（ES6的class） 2.原则：遵守单一职责的原则 3.一个类组件包含： 属性：props 内部状态 处理逻辑 事件处理 渲染：render 生命周期函数 4.组件创建技巧 尽可能无状态化 减少冗余 创建多个只负责渲染数据的无状态组件，在他们的上层创建一个有状态的组件并把状态通过props传递给子级 有状态组件封装了所有用户的交互逻辑，无状态组件只负责声明式渲染","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Redis和Memcache","date":"2018-11-05T11:34:32.000Z","path":"2018/11/05/缓存/Redis和Memcache/","text":"Redis和Memcahe的对比 Redis不仅支持键值对的存储，还支持list，set，hash，zset（有序集合）数据结构的存储+","tags":[]},{"title":"kafka","date":"2018-11-02T13:00:00.000Z","path":"2018/11/02/Kafka/kafka/","text":"kafka是一个分布式消息队列。具有高性能、持久化、多副本备份、横向拓展能力。 kafka对外使用topic的概念，生产者往topic里写消息，消费者从topic中读消息。一个topic实际是由多个partition组成的，遇到瓶颈时，可以通过增加partition的数量来进行横向扩容。单个parition内是保证消息有序。 **Kafka ActiveMQ RabbitMQ对比 1、 TPS Kafka最高，RabbitMq次之，ActiveMq最差 2、 吞吐量对比kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)复杂度，消息处理的效率很高。 Zero-Copy技术12345678910通常情况下文件从读取到通过Socket发送进行了4次拷贝：1、调用read时，文件A拷贝到了kernel模式；2、CPU控制将kernel模式数据copy到user模式下；3、调用write时，先将user模式下的内容copy到kernel模式下的socket的buffer中；4、将kernel模式下的socket buffer的数据copy到网卡设备中传送；Zero-Copy技术省去了将操作系统的read buffer拷贝到程序的buffer，以及从程序buffer拷贝到socket buffer的步骤，1、将文件拷贝到kernel buffer中；2、向socket buffer中追加当前要发生的数据在kernel buffer中的位置和偏移量；3、根据socket buffer中的位置和偏移量直接将kernel buffer的数据copy到网卡设备（protocol engine）中； 3、在架构模型方面RabbitMQ实现了AMQP协议（advanced message queue protocol高级消息队列协议）RabbitMQ有消息确认机制；Kafka遵从一般的MQ结构，无消息确认机制。4、在可用性方面RabbitMQ支持miror的queue，主queue失效，miror queue接管。Kafka的broker支持主备模式ActiveMq也支持主备模式 Kafka的优缺点 优点： 主要用来解决百万级别的数据中生产者和消费者之间数据传输 可以将一条数据提供给多个接受短做不同的处理 两个系统间的通讯 做为日志的收集的一环 kafka吞吐量高，单机吞吐量kafka达十万级，而ActiveMQ，RabbitMQ，RocketMQ的吞吐量为万级。 分布式容灾好 数据量不会影响到KafKa的速度 缺点： 不支持事务 重复消息。Kafka保证每条消息至少送达一次，虽然几率很小，但一条消息可能被送达多次 消息乱序。Kafka某一个固定的Partition内部的消息是保证有序的，如果一个Topic有多个Partition，partition之间的消息送达不保证有序。 复杂性。Kafka需要Zookeeper的支持，Topic一般需要人工创建，部署和维护比一般MQ成本更高","tags":[{"name":"kafka","slug":"kafka","permalink":"http://yoursite.com/tags/kafka/"}]},{"title":"Linux常用命令","date":"2018-10-31T13:00:00.000Z","path":"2018/10/31/Linux/Linux常用命令/","text":"查看使用内存最多的10个进程 ps -aux | sort -k4nr | head -n 10 top （然后按下M，注意大写） 查看使用CPU最多的10个进程 ps -aux | sort -k3nr | head -n 10 top （然后按下P，注意大写)ps命令参数解释 123-a ： 显示现行终端机下的所有进程，包括其他用户的进程；-u ： 以用户为主的进程状态 ；x ： 通常与 a 这个参数一起使用，可列出较完整信息。 查看网卡流量 watch more /proc/net/dev 可以查看每2秒的字节和数据包的变化","tags":[]},{"title":"Linux文本处理常用命令","date":"2018-10-30T13:00:00.000Z","path":"2018/10/30/Linux/Linux文本处理常用命令/","text":"Linux文本处理常用命令：grep、sed、printf、awk、cut、sort 1. grep按行查找字符，输出包含字符的行用法 grep ‘key’ test.txt cat test.txt|grep ‘key’ 参数 含义及示例 -n 输出结果加行号 –color=auto 匹配的关键字高亮显示 -A2 输出匹配行的后两行 -B2 输出匹配行的前两行 -v 反向查找，即输出不包含关键字的行 -i 关键字匹配时忽略关键字大小写 例如：1grep &apos;o\\&#123;3\\&#125;&apos; //查找两个o，这里需要注意，&#123;&#125;在shell里有特殊意义，因此需要转义。 egrep:正则表达式分为基本正则表达式和扩展正则表达式，grep只支持基本正则表达式，如果要使用扩展正则表达式，需要使用egrep命令列如：123egrep &apos;123|1234&apos; //查找123或1234egrep &apos;1(23|234)5&apos; //查找1235或12345egrep &apos;1(23)+45&apos; //查找1X45，其中X是一个或一个以上的‘23’字符串 2.sedsed可以用来做行删除、行新增、行选取、行替换、字符串替换使用方式：cat test.txt | sed ‘2d’ 或者 sed ‘2d’test.txt 行删除sed ‘2,5d’ //删除第2-5行sed ‘3,$d’ //删除第3到最后一行sed ‘/^$/d’//删除空行 行新增sed ‘2a abc’ //在第二行下面追加一行“abc”，a代表appendsed ‘2i abc’ //在第二行上面插入一行 “abc”，i代表insertsed ‘2a a\\b\\c’ //在第二行下面追加三行 “a”、”b”、”c”，只需要每行结尾加”\\”即可。 行选取sed -n ‘7,9p’ //选取第5到7行输出，必须加-n参数，不然效果就是所有行都被输出，而7到9行输出两次。 行替换sed ‘2,5c abc’ //将第2到5行替换为一行字符串”abc” 字符串替换sed ‘s/要被替换的字符串/新的字符串/g’ /可以是#号之类的，在被替换的字符串包含/时，可以考虑别的分隔符。要被替换的字符串可以是正则表达式 注意：12345678910操作特定区间或规则的行sed &apos;8,$s/aa/AA/g&apos; test.txt 对第8行到文件末尾的所有行进行搜索替换操作sed &apos;/^[0-9]/s/aa/AA/g&apos; test.txt 正则表达式表示对所有以数字开头的行，执行s操作sed的正则中 \\(\\) 和 \\&#123;m,n\\&#125; 需要转义. 表示任意字符* 表示零个或者多个\\+ 一次或多次 \\? 零次或一次\\| 表示或语法 3. printf格式化并打印数据printf ‘%10s %10s %10s %10s %10s \\n’ cat test.txt %10s代表这一列的宽度固定为10个字符%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐） 4. awkNF ：每一行分隔后的列数NR ：行号FS=”,”：以”,”分割行cat test.txt |awk ‘NR==1 {printf “%10s %10s %10s %10s %10s \\n”,$1,$2,$3,$4,”Total”};NR&gt;1 {printf “%10s %10s %10s %10s %10s \\n”,$1,$2,$3,$4,$2+$3+$4}’ 加入条件判断后，awk的格式为： awk ‘条件1 {命令1};条件2{命令2}’ 条件判断有以下逻辑运算： 123456&gt;&lt;&gt;=&lt;=== //注意判断相等要用两个等号!= 可以直接运算行内列的值($1、$2、$3)。 5. 其他1）cut切割字符 以“，”切割文件并取出第1列cat test.txt |cut -d ‘,’ -f 1| sort | uniq -c | sort -rn -k1 &gt; new_test.txt 2）sort排序的时候注意默认是按照字典的方式排序，如果按照数字时则必须加上-n uniq去除重复，只能去除相邻的重复，所以要先排序，后去除重复 命令 用途 grep/egrep 关键字查找 sed 1.行的删除、添加、替换、选取 2.关键字替换 printf 文本格式化输出 awk 1. 将每行按分隔符拆分成列并选取某些列2. 通过逻辑判断对不同行进行不同的处理3.对一行中的几列数值进行计算 cat 切割字符 sort 排序","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux命令","date":"2018-10-30T12:00:00.000Z","path":"2018/10/30/Linux/Linux命令/","text":"sort常用参数 -n ： 依照数值的大小排序。(不加-n参数，默认按照字符ASSII码的排序 会出现如（1,11,2,3..）这样的排序) -k 指定按某一列排序 从1开始。 -r: 以相反的顺序来排序。(默认是从小到大，加上-r即从大到小) -t 设定分隔符,使用指定的分隔符代替非空格到空格的转换 -b 忽略每行前面开始出的空格字符。 -c 检查文件是否已经按照顺序排序。 -d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。 -f 排序时，将小写字母视为大写字母。 -i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。 -m 将几个排序好的文件进行合并。 -M 将前面3个字母依照月份的缩写进行排序。 -o&lt;输出文件&gt; 将排序后的结果存入指定的文件。 +&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。sort -n -k 2 -t’-‘ test.txt123456789101112//原来的内容[root@h2 ~]# cat test.txt2018-12-012013-01-082015-10-242016-04-25[root@h2 ~]# sort -nk2 -t&apos;-&apos; test.txt2013-01-082016-04-252015-10-242018-12-01 headhead用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。 -n&lt;数字&gt; –lines=[-]K ：指定显示头部内容的行数；如果附加”-“参数，则除了每个文件的最后K 行外显示剩余全部内容 -v：总是显示文件名的头信息； -q：不显示文件名的头信息。 -c, –bytes=[-]K 显示每个文件的前K 字节内容 uniq只过滤相邻的重复行。 -c, –count 在每行前加上表示相应行目出现次数的前缀编号 find find base_path 列出当前目录和子目录下的所有文件和文件夹 find path -name ‘*txt’ 根据文件名或者正则表达式匹配搜索 find path -iname ‘*txt’ 同上，忽略大小写 find path ! -name ‘*txt’ 对上面的搜索结果取反 find path -type d 根据文件类型搜索，d文件夹，f普通文件，etc find path -type f -size +2k 根据文件大小搜索，+2k大于2k的文件，-2k小于2k的文件，2k等你2k的文件 find path -type f -name ‘*txt’ -delete 删除匹配到的文件 find path -mtime -2 查找文件更新日时在距现在时刻二天以内的文件 find path -mtime +2 查找文件更新日时在距现在时刻二天以上的文件 find path -mtime 2 查找文件更新日时在距现在时刻一天以上二天以内的文件 find path -mmin -2 查找文件更新日时在距现在时刻二分以内的文件 find path -mmin +2 查找文件更新日时在距现在时刻二分以上的文件 find path -mmin 2 查找文件更新日时在距现在时刻一分以上二分以内的文件 find path -perm 664 查找权限为664的文件或目录(需完全符合) find path -empty 查找空文件或空目录 find path -empty -type f -print -delete查找空文件并删除 find path -size -10c 查找文件size小于10个字节的文件或目录 find path -size 10c 查找文件size等于10个字节的文件或目录 find path -size +10c 查找文件size大于10个字节的文件或目录 find path -size -10k 查找文件size小于10k的文件或目录 find path -size -10M 查找文件size小于10M的文件或目录 find path -size -10G 查找文件size小于10G的文件或目录","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Git创建本地分支并关联远程分支","date":"2018-10-29T06:16:57.000Z","path":"2018/10/29/Git/Git创建本地分支并关联远程分支/","text":"创建本地分支 git branch 分支名 切换到本地分支 git checkout 分支名 创建本地分支并切换到该分支 git checkout -b 分支名 提交本地分支到远程仓库 git push origin 本地分支名 将新建的本地分支与远程分支关联-git branch –set-upstream-to=origin/远程分支名 本地分支名 使用git branch –set-upstream 本地分支名 origin/远程分支名 命令报如下错误fatal: the ‘–set-upstream’ option is no longer supported. Please use ‘–track’ or ‘–set-upstream-to’ instead.","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git常用命令","date":"2018-10-19T09:28:38.000Z","path":"2018/10/19/Git/Git常用命令/","text":"git init 在本地当前目录初始化一个git仓库 git clone git status git log git add git diff git commit git reset git revert git rm git clean git mv git stash git branch git checkout git merge git tag git remote git fetch git pull git rebase git push","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"设计模式","date":"2018-10-19T08:08:41.000Z","path":"2018/10/19/DesignPattern/设计模式/","text":"设计模式的分类设计模式分为三大类： 创建型模式，共五种： 工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式 结构型模式，共七种： 适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式 行为型模式，共十一种： 策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式 设计模式的六大原则1、单一职责原则 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 4、接口隔离原则（Interface Segregation Principle） 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5、迪米特法则（最少知道原则）（Demeter Principle） 一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 6、合成复用原则（Composite Reuse Principle） 原则是尽量首先使用合成/聚合的方式，而不是使用继承。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"【Java并发】Java多线程Future的使用","date":"2018-10-17T13:00:00.000Z","path":"2018/10/17/Java并发/【Java并发】Java多线程Future的使用/","text":"Future模式简述 在传统单线程环境下，调用函数是同步的，必须等待程序返回结果后，才可进行其他处理。 Future模式下，调用方式改为异步。 Future模式的核心在于：充分利用主函数中的等待时间，利用等待时间处理其他任务，充分利用计算资源示例代码： 123456789101112131415161718import java.util.concurrent.Callable;public class ManipulationDataTask implements Callable&lt;String&gt; &#123; private String data; public ManipulationDataTask(String data) &#123; this.data = data; &#125; @Override public String call() throws Exception &#123; String data1 = data.toUpperCase(); System.out.println(Thread.currentThread().getName() + \"业务处理线程处理中...\"); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \"业务处理线程处理完成,处理好的数据为\" + data1); return data1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;public class MainTest &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; FutureTask&lt;String&gt; future1 = new FutureTask&lt;String&gt;(new ManipulationDataTask(\"abc\")); FutureTask&lt;String&gt; future2 = new FutureTask&lt;String&gt;(new ManipulationDataTask(\"def\")); FutureTask&lt;String&gt; future3 = new FutureTask&lt;String&gt;(new ManipulationDataTask(\"ghi\")); ManipulationDataTask manipulationDataTask = new ManipulationDataTask(\"jkl\"); ExecutorService executor = Executors.newFixedThreadPool(3); executor.submit(future1); executor.submit(future2); executor.submit(future3); Future&lt;String&gt; future4 =executor.submit(manipulationDataTask); System.out.println(\"请求完毕！\"); try &#123; System.out.println(\"主线程先去做点别的事\"); Thread.sleep(5000); System.out.println(\"主线程的事情做完了\"); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(\"主线程开始获取子任务处理完的结果\"); System.out.println(\"数据处理完成：\" + future1.get()); System.out.println(\"数据处理完成：\" + future2.get()); System.out.println(\"数据处理完成：\" + future3.get()); System.out.println(\"数据处理完成：\" + future4.get()); executor.shutdown(); &#125;&#125; 程序运行结果：12345678910111213141516请求完毕！主线程先去做点别的事pool-1-thread-1业务处理线程处理中...pool-1-thread-2业务处理线程处理中...pool-1-thread-3业务处理线程处理中...pool-1-thread-1业务处理线程处理完成,处理好的数据为ABCpool-1-thread-1业务处理线程处理中...pool-1-thread-2业务处理线程处理完成,处理好的数据为DEFpool-1-thread-3业务处理线程处理完成,处理好的数据为GHIpool-1-thread-1业务处理线程处理完成,处理好的数据为JKL主线程的事情做完了主线程开始获取子任务处理完的结果数据处理完成：ABC数据处理完成：DEF数据处理完成：GHI数据处理完成：JKL","tags":[{"name":"java并发","slug":"java并发","permalink":"http://yoursite.com/tags/java并发/"}]},{"title":"幽静的小路","date":"2018-10-17T10:05:34.000Z","path":"2018/10/17/Journey/幽静的小路/","text":"蝴蝶效应的影响，在前期的时候，因为别人或者环境的影响，很长的一段时间，心情很悲伤，心态上的悲观，导致后来的我遇到自己所爱的事物时，心中想着我本可以，却发现怎么都追赶不上了，前期的一次心态不好，会对后来的自己产生巨大的影响。回想起来，当自己再经历一遍时，发现我还是不能改变环境和别人对我的影响，那时候的我是在感情用事吗？还是自己没有气度呢？唯一能做的是改变自己，改变自己的心态和状态。 人可以不认识人，但是灵魂认识灵魂如果你抓住深渊不放，深渊也会抓住你不放马太效应 凡是有的，还要加给他，叫他多余。没有的，连他所有的，也要夺过来。任何时候，不要太悲伤，其实自己拥有很多，so far so good。 一个人有多好就有多坏，常怀慈悲之心，生而为人，务必善良。","tags":[{"name":"悟","slug":"悟","permalink":"http://yoursite.com/tags/悟/"}]},{"title":"java关键字transient,volatile","date":"2018-10-15T10:30:53.000Z","path":"2018/10/15/Java/java关键字transient-volatile/","text":"被transient关键字修饰的变量不会被序列化被volatile关键字修饰的变量，每次被线程访问时，都会强制从共享内存中重读改变量的值，但是不具备原子性被volatile关键字修饰的变量的，具有以下两点特性： 保证了不同线程对该变量操作的内存可见性，不保证原子性。 禁止指令重排序 在java的内存模型中，JMM规定对于多个线程共享变量都存在主存中的，每个线程包含自己的工作内存，工作内存保存了主内存共享的变量，其中一个线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步会主内存中。在其他线程未将共享变量同步会自己的工作内存之前，共享变量的改变对其不可见的。也就是说其他线程的工作内存中的变量已经过时了。 volatile是通过内存屏障和禁止指令重排序来保证内存可见性的，一个线程对volatile变量的修改，能即刻被其他线程所见，但是不保证原子性。 使用volatile提供理想的线程安全，需要满足以下两个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 volatile变量不能用来做线程安全的计数器 volatile的适用场景 1. 状态标志注意：这种状态标记通常只有一种状态转换如果需要状态的来回转换，可以使用原子变量。 2. 一次性安全发布3. 独立观察定期“发布”观察结果供程序内部使用 4. “volatile bean”模式5. 开销较低“读-写锁”策略 状态位 一个线程写，多个线程读的场景","tags":[]},{"title":"Hello World","date":"2018-10-15T08:05:35.909Z","path":"2018/10/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"SpringAOP原理","date":"2018-10-01T15:06:32.000Z","path":"2018/10/01/Java/SpringAOP原理/","text":"AOP（Aspect-OrientedProgramming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。AOP使用场景 权限 缓存 内容传递 错误处理 懒加载 调试 记录跟踪 优化 校准 持久化 资源池 同步 事务","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"Github 提交代码 Emoji","date":"2017-08-09T15:55:41.000Z","path":"2017/08/09/Git/GithubEmoji/","text":"An emoji guide for your commit messages: gitmoji Code Emoji 描述 :art: :art: 改进代码的结构/格式 :zap: :zap: 提高性能 :fire: :fire: 删除代码或文件 :bug: :bug: 修复bug :ambulance: :ambulance: 关键修补程序 :sparkles: :sparkles: 引入新功能 :memo: :memo: 写文档 :rocket: :rocket: 部署项目 :lipstick: :lipstick: 更新UI和样式文件 :tada: :tada: 初始提交 :white_check_mark: :white_check_mark: 添加测试 :lock: :lock: 解决安全问题 :apple: :apple: 修改 macOS 下的一些问题 :penguin: :penguin: 修改 Linux 下的一些问题 :checkered_flag: :checkered_flag: 修改 Windows 下的一些问题 :robot: :robot: 修改 Android 下的一些问题 :green_apple: :green_apple: 修改 IOS 下的一些问题 :bookmark: :bookmark: 发布版本标签 :rotating_light: :rotating_light: 移除 linter 警告 :construction: :construction: 工作正在进行中 :green_heart: :green_heart: 修复CI构建 :arrow_down: :arrow_down: 降级依赖 :arrow_up: :arrow_up: 更新依赖 :construction_worker: :construction_worker: 添加CI构建系统 :chart_with_upwards_trend: :chart_with_upwards_trend: 添加分析或跟踪代码 :hammer: :hammer: 重构代码 :heavy_minus_sign: :heavy_minus_sign: 删除依赖关系 :whale: :whale: 关于Docker的工作 :heavy_plus_sign: :heavy_plus_sign: 添加依赖关系 :wrench: :wrench: 更改配置文件 :globe_with_meridians: :globe_with_meridians: 国际化和本地化 :pencil2: :pencil2: 修正打字错误 :hankey: :hankey: 编写不好的代码，需要改进 :rewind: :rewind: 还原更改 :twisted_rightwards_arrows: :twisted_rightwards_arrows: 合并分支 :package: :package: 更新已编译的文件或包 :alien: :alien: 由于外部API更改而更新代码 :truck: :truck: 移动或重命名文件 :page_facing_up: :page_facing_up: 添加或更新许可证 :boom: :boom: 引入爆炸改变 :bento: :bento: 添加或更新资源 :ok_hand: :ok_hand: 由于代码审查更改而更新代码 :wheelchair: :wheelchair: 改善无障碍 :bulb: :bulb: 文档化源代码 :beers: :beers: 沉迷写代码 :speech_balloon: :speech_balloon: 更新文本和常量 :card_file_box: :card_file_box: 执行数据库相关更改","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}]